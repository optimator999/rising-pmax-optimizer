# Image Asset Management System

## Overview

Phase 2 of the Rising PMax Optimizer adds intelligent image asset management. Phase 1 (complete) collects image performance data, flags underperformers by CTR, and reports them in Slack. Phase 2 builds the infrastructure to store, analyze, organize, and recommend image assets.

**The problem:** When an image gets flagged for low CTR, the operator has no system-assisted way to choose a replacement. Image selection is manual, intuition-driven, and doesn't account for asset group composition, content diversity, or historical performance patterns.

**The solution:** An S3-based image repository with AI-generated metadata, campaign-aware composition profiles, and a gap analysis engine that recommends what to upload next.

### Goals

1. Every image asset has structured metadata describing its content, generated by Claude Vision at upload time
2. Each campaign has a defined ideal image composition profile (content category distribution)
3. The system identifies gaps between current asset group composition and the ideal profile
4. When an image is flagged, the system recommends replacement candidates from the repository
5. Performance data feeds back into composition insights over time

### Non-Goals (Phase 2)

- Automated image upload to Google Ads (manual for now)
- Image generation or editing
- Dynamic profile rebalancing (Phase 3)
- Auto-cropping or aspect ratio conversion (future)

---

## Architecture

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   S3: rising-pmax â”‚
                    â”‚   â”œâ”€â”€ images/            â”‚
                    â”‚   â””â”€â”€ (organized by ID)  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                â”‚                 â”‚
              â–¼                â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DynamoDB:        â”‚ â”‚ Lambda:         â”‚ â”‚ Lambda:              â”‚
â”‚ image_registry   â”‚ â”‚ image_ops       â”‚ â”‚ weekly_review        â”‚
â”‚                  â”‚ â”‚                 â”‚ â”‚ (existing)           â”‚
â”‚ - AI metadata    â”‚ â”‚ - Bootstrap     â”‚ â”‚                      â”‚
â”‚ - Performance    â”‚ â”‚ - Upload + tag  â”‚ â”‚ - Reads registry for â”‚
â”‚ - Upload history â”‚ â”‚ - Gap analysis  â”‚ â”‚   enriched flagging  â”‚
â”‚ - Mapping to     â”‚ â”‚ - Crop check   â”‚ â”‚ - Writes performance â”‚
â”‚   Google Ads     â”‚ â”‚                 â”‚ â”‚   back to registry   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### New Components

| Component | Type | Purpose |
|-----------|------|---------|
| `src/image_manager.py` | Module | S3 operations, Claude Vision analysis, registry CRUD |
| `lambda_functions/image_ops.py` | Lambda | Bootstrap, upload, gap analysis entry points |
| `rising-pmax` | S3 Bucket | Image file storage |
| `rising_image_registry` | DynamoDB Table | Image metadata, mapping, and performance |

### Existing Components Modified

| Component | Change |
|-----------|--------|
| `config/settings.py` | Add `image_profile` to each campaign config |
| `database/queries.py` | Add image registry table operations |
| `lambda_functions/weekly_review.py` | Write image performance back to registry |
| `src/slack_notifier.py` | Enrich flagged image reports with registry metadata |
| `deployment/terraform/main.tf` | Add S3 bucket, DynamoDB table, IAM permissions |

---

## S3 Bucket Structure

```
rising-pmax/
  â””â”€â”€ images/
      â”œâ”€â”€ {image_id}.jpg
      â”œâ”€â”€ {image_id}.png
      â””â”€â”€ ...
```

Images are stored flat by `image_id` (UUID). No folder hierarchy by campaign â€” images can be used across campaigns. All organization is in the DynamoDB registry, not the file system.

**S3 Object Metadata** (set at upload time):
- `image_id`: UUID, matches DynamoDB registry key
- `source`: `google_ads_bootstrap` | `manual_upload`
- `uploaded_at`: ISO timestamp

All content metadata lives in DynamoDB, not S3 object metadata. S3 metadata has a 2KB limit and isn't queryable. S3 is dumb storage; DynamoDB is the brain.

---

## DynamoDB Schema

### `rising_image_registry`

**Key:** `image_id` (HASH)

| Field | Type | Description |
|-------|------|-------------|
| `image_id` | String | UUID, primary key |
| `s3_key` | String | S3 object key (e.g., `images/{image_id}.jpg`) |
| `filename_original` | String | Original filename before upload |
| `source` | String | `google_ads_bootstrap` or `manual_upload` |
| `native_aspect_ratio` | String | `landscape`, `square`, `portrait` |
| `width_px` | Number | Image width in pixels |
| `height_px` | Number | Image height in pixels |
| `file_size_bytes` | Number | File size |
| **AI Metadata** | | |
| `content_category` | String | Primary category (see taxonomy below) |
| `product_visible` | Boolean | Is a Rising product clearly visible? |
| `human_present` | Boolean | Is a person visible? |
| `scene_type` | String | `river`, `lake`, `workshop`, `studio`, `outdoor_other` |
| `background_complexity` | String | `simple`, `moderate`, `complex` |
| `text_overlay` | Boolean | Does the image contain baked-in text? |
| `product_frame_ratio` | String | `tight` (>50%), `medium` (20-50%), `wide` (<20%), `none` |
| `lighting` | String | `natural_outdoor`, `studio`, `warm`, `cool` |
| `seasonal_relevance` | List[String] | `spring`, `summer`, `fall`, `winter`, `all_season` |
| `ai_description` | String | One-sentence Claude Vision summary |
| `ai_analysis_model` | String | Model used for analysis (e.g., `claude-sonnet-4-5-20250929`) |
| `ai_analyzed_at` | String | ISO timestamp of analysis |
| **Crop Eligibility** | | |
| `eligible_slots` | Map | `{MARKETING_IMAGE: "native", SQUARE_MARKETING_IMAGE: "crop_viable", PORTRAIT_MARKETING_IMAGE: "not_recommended"}` |
| **Google Ads Mapping** | | |
| `google_ads_assets` | List[Map] | `[{asset_resource, campaign_name, asset_group, field_type, date_linked, date_unlinked}]` |
| **Performance** (updated weekly) | | |
| `performance_by_campaign` | Map | `{campaign_name: {impressions, clicks, ctr, cost, last_updated}}` |
| `overall_ctr` | Number | Weighted CTR across all campaigns |
| **Lifecycle** | | |
| `status` | String | `available`, `in_use`, `retired` |
| `related_images` | List[String] | image_ids of crops/variants from same source |
| `created_at` | String | ISO timestamp |
| `updated_at` | String | ISO timestamp |

**GSI: `campaign-slot-index`**
- Partition key: None (scan-based for now; image counts are low)
- Purpose: Future optimization if image volume grows

**Design decisions:**
- Google Ads mapping is embedded in the registry item (not a separate table). With low image volume (<100), a separate mapping table adds complexity without benefit. The `google_ads_assets` list stores every campaign/asset_group the image has been used in, creating full history.
- Performance data is denormalized onto the registry item. The weekly review writes aggregated CTR back after each run. This avoids cross-table joins.
- AI metadata is immutable after initial analysis. Content doesn't change; only performance data updates weekly.

---

## Content Category Taxonomy

These categories drive composition analysis and gap detection.

| Category | Description | Example |
|----------|-------------|---------|
| `product_hero` | Product is the clear subject against a clean/simple background | Net on white, net held up against sky |
| `product_detail` | Close-up of craftsmanship, materials, features | Knot pattern, wood grain, hoop joint |
| `product_in_use` | Person actively using the product in context | Landing a fish with the net, wading with net on back |
| `lifestyle_with_product` | Aspirational scene with product visible but not the focus | River scene with angler, net visible at hip |
| `lifestyle_no_product` | Brand/mood imagery, no product visible | River at dawn, hands tying a fly, truck tailgate |

### Content Category Selection Rules (for Claude Vision)

The AI must pick exactly one primary `content_category`. Decision order:
1. Is a Rising product clearly the main subject with a simple background? â†’ `product_hero`
2. Is the image a close-up of product materials/construction? â†’ `product_detail`
3. Is someone actively using a Rising product? â†’ `product_in_use`
4. Is a Rising product visible in a broader scene? â†’ `lifestyle_with_product`
5. No product visible? â†’ `lifestyle_no_product`

---

## Campaign Image Profiles

Stored in `config/settings.py` alongside existing campaign config.

```python
CAMPAIGNS = {
    "Core Brand": {
        "campaign_id": "22483972722",
        "asset_group": "Core Brand",
        "slug": "core_brand",
        "image_profile": {
            "product_hero": 0.20,
            "product_in_use": 0.30,
            "lifestyle_with_product": 0.30,
            "lifestyle_no_product": 0.10,
            "product_detail": 0.10,
        },
    },
    "Replacement Nets": {
        "campaign_id": "22494027316",
        "asset_group": "Replacement Nets",
        "slug": "replacement_nets",
        "image_profile": {
            "product_hero": 0.25,
            "product_detail": 0.30,
            "product_in_use": 0.25,
            "lifestyle_with_product": 0.15,
            "lifestyle_no_product": 0.05,
        },
    },
}
```

### Profile Rationale

**Core Brand** (prospecting â€” new customers):
- Heavy on `product_in_use` and `lifestyle_with_product` (60% combined): New customers need to see the product in context to understand what it is and how it's used
- 20% `product_hero`: Clean product shots for Display and Shopping-style placements
- 10% `lifestyle_no_product`: Brand building, but limited â€” strangers need product, not vibes
- 10% `product_detail`: Craftsmanship signals quality, but secondary for first impressions

**Replacement Nets** (retention â€” existing customers):
- Heavy on `product_detail` and `product_hero` (55% combined): Existing customers know the brand. Show them what's new â€” materials, colors, construction improvements
- 25% `product_in_use`: Remind them of the experience, show the new model in action
- 15% `lifestyle_with_product`: Light brand reinforcement
- 5% `lifestyle_no_product`: Minimal â€” these buyers don't need convincing about the lifestyle

### Profile Evaluation

The gap analysis compares actual image distribution to the profile target:

```
Core Brand â€” Image Composition Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Category              Actual   Target   Gap
product_hero           10%      20%     â–¼ UNDER (-10%)
product_in_use         10%      30%     â–¼ UNDER (-20%)  â† priority
lifestyle_with_product 50%      30%     â–² OVER (+20%)
lifestyle_no_product   20%      10%     â–² OVER (+10%)
product_detail         10%      10%     âœ“ ON TARGET

Recommendation: Upload 2 product_in_use images and 1 product_hero.
Your asset group is too lifestyle-heavy for a prospecting campaign.
New customers need to see the product.
```

---

## AI Image Analysis

### Claude Vision Prompt

Each image is analyzed once at upload time using a structured prompt:

```
Analyze this image for a fly fishing brand's Google Ads Performance Max campaign.
Return a JSON object with exactly these fields:

{
  "content_category": one of "product_hero", "product_detail", "product_in_use",
                      "lifestyle_with_product", "lifestyle_no_product",
  "product_visible": true/false,
  "human_present": true/false,
  "scene_type": one of "river", "lake", "workshop", "studio", "outdoor_other",
  "background_complexity": one of "simple", "moderate", "complex",
  "text_overlay": true/false,
  "product_frame_ratio": one of "tight", "medium", "wide", "none",
  "lighting": one of "natural_outdoor", "studio", "warm", "cool",
  "seasonal_relevance": list from ["spring", "summer", "fall", "winter", "all_season"],
  "description": one sentence describing the image content
}

The product is a handcrafted fly fishing landing net made from wood.
If a net-shaped object is visible, product_visible is true.
For content_category, follow this priority:
1. Product is main subject on simple background â†’ product_hero
2. Close-up of materials/craftsmanship â†’ product_detail
3. Person actively using the product â†’ product_in_use
4. Product visible in a broader scene â†’ lifestyle_with_product
5. No product visible â†’ lifestyle_no_product
```

### Crop Eligibility Assessment

After content analysis, a second pass evaluates crop viability:

```
This image is {width}x{height} ({native_aspect_ratio}).
Can it be cropped to the following aspect ratios while keeping the main
subject visible and well-composed?

- Landscape 1.91:1 (1200x628): viable / not_recommended
- Square 1:1 (1200x1200): viable / not_recommended
- Portrait 4:5 (960x1200): viable / not_recommended

Return JSON: {"landscape": "viable"|"not_recommended",
              "square": "viable"|"not_recommended",
              "portrait": "viable"|"not_recommended"}
```

Both analyses run in a single Claude API call to minimize cost.

### Analysis Cost

- Estimated ~$0.01-0.02 per image (Claude Sonnet with vision)
- Bootstrap of ~20-30 existing images: < $1.00
- Ongoing: analyzed once at upload, never re-analyzed
- Model tracked in `ai_analysis_model` field for reproducibility

---

## Bootstrap Process

One-time operation to populate the registry from existing Google Ads image assets.

### Steps

1. **Query Google Ads** for all image assets in each campaign's asset groups
   - Uses existing `_search()` method with a query selecting `asset.image_asset.full_size.url`, `asset.image_asset.full_size.width_pixels`, `asset.image_asset.full_size.height_pixels`, `asset.name`, `asset_group_asset.asset`, `asset_group_asset.field_type`
2. **Download images** from the Google-hosted URLs (temporary signed URLs returned by API)
3. **Generate image_id** (UUID) for each unique image
4. **Upload to S3** at `images/{image_id}.{ext}`
5. **Run Claude Vision analysis** to generate AI metadata
6. **Create registry entry** in DynamoDB with all metadata + Google Ads mapping pre-populated
7. **Link performance data** from existing `rising_asset_performance` records using `asset_resource`

### Deduplication

The same image file may appear in multiple asset groups or campaigns. During bootstrap:
- Hash the image bytes (SHA-256)
- If the hash matches an existing registry entry, don't create a duplicate â€” add the additional Google Ads mapping to the existing entry
- This handles the case where the same photo is used in both Core Brand and Replacement Nets

### Bootstrap Lambda Event

```json
{
  "action": "bootstrap",
  "campaigns": ["Core Brand", "Replacement Nets"]
}
```

---

## Gap Analysis Engine

Compares current asset group composition against the campaign's `image_profile`.

### Inputs

1. Campaign name â†’ image profile from config
2. Current image assets in the campaign's asset group (from registry, filtered by `google_ads_assets` mapping where `date_unlinked` is null)
3. Each image's `content_category` from AI metadata

### Algorithm

```python
def gap_analysis(campaign_name):
    profile = CAMPAIGNS[campaign_name]["image_profile"]
    active_images = get_active_images_for_campaign(campaign_name)
    total = len(active_images)

    actual_distribution = count_by_category(active_images)
    gaps = {}

    for category, target_pct in profile.items():
        actual_pct = actual_distribution.get(category, 0) / total if total > 0 else 0
        gap = target_pct - actual_pct
        gaps[category] = {
            "target": target_pct,
            "actual": round(actual_pct, 2),
            "delta": round(gap, 2),
            "count": actual_distribution.get(category, 0),
        }

    # Sort by largest negative gap (most underrepresented)
    priority = sorted(gaps.items(), key=lambda x: x[1]["delta"], reverse=True)
    return gaps, priority
```

### Output

The gap analysis produces:
1. **Composition table** â€” actual vs target per category
2. **Priority list** â€” categories ranked by deficit
3. **Recommendation** â€” plain-English suggestion (e.g., "Upload 2 product_in_use images")
4. **Candidate list** â€” if the repository has unused images that fit the gap, surface them

### When It Runs

- On demand via Lambda event: `{"action": "gap_analysis", "campaign": "Core Brand"}`
- Automatically after weekly review (appended to Slack message if gaps detected)
- After new image uploads (immediate feedback on whether the upload improved composition)

---

## Integration with Weekly Review

### Performance Writeback

After the weekly review collects image performance data (Phase 1), it writes aggregated metrics back to the image registry:

```python
# In weekly_review.py, after image performance collection
for img_asset in image_assets:
    image_id = lookup_image_id_by_asset_resource(img_asset["asset_resource"])
    if image_id:
        update_image_performance(image_id, campaign_name, {
            "impressions": img_asset["impressions"],
            "clicks": img_asset["clicks"],
            "ctr": img_asset["ctr"],
            "cost": img_asset["cost"],
        })
```

### Enriched Flagging

When an image is flagged for low CTR, the Slack message includes registry context:

```
âŒ IMAGE 1: lifestyle-river-shot-03
   Type: MARKETING_IMAGE
   Category: lifestyle_with_product
   Stats: 1,240 impr | 0.8% CTR | $12.50 spent
   Action: Replace in Google Ads > Assets

   ðŸ’¡ Your Core Brand asset group is 50% lifestyle (target: 40%).
      Consider replacing with a product_in_use image.
      Available in repo: product-in-use-walnut-net-01, product-in-use-landing-trout-02
```

---

## Lambda Function: image_ops

### Event Schema

```json
{
  "action": "bootstrap | upload | gap_analysis | analyze",
  "campaigns": ["Core Brand"],
  "s3_key": "images/abc123.jpg",
  "image_id": "abc123"
}
```

### Actions

| Action | Description | Trigger |
|--------|-------------|---------|
| `bootstrap` | Pull all images from Google Ads, analyze, register | One-time manual |
| `upload` | Register a manually uploaded S3 image (analyze + metadata) | After S3 upload |
| `gap_analysis` | Run composition analysis for campaign(s) | On demand / post-review |
| `analyze` | Re-analyze a specific image (if model upgraded) | Manual |

### Runtime

- Python 3.12
- Memory: 1024 MB (image processing + Claude API calls)
- Timeout: 300 seconds (bootstrap may process 20-30 images)
- Layer: shared `rising-pmax-dependencies` + Pillow for image dimensions

---

## Metrics

### System Health

| Metric | Target | How Measured |
|--------|--------|-------------|
| Registry coverage | 100% of live Google Ads image assets mapped | Count of unmapped `asset_resource` values |
| Metadata completeness | 100% of registered images have AI analysis | Count where `ai_analyzed_at` is null |
| Performance freshness | Updated within 7 days | Max `last_updated` in `performance_by_campaign` |
| Bootstrap success | All existing assets imported | Compare Google Ads asset count to registry count |

### Composition Quality

| Metric | Target | How Measured |
|--------|--------|-------------|
| Composition deviation | < 15% from profile per category | Max absolute gap in gap analysis |
| Category coverage | No category at 0% | All profile categories have >= 1 image |
| Diversity score | No single category > 50% | Max category percentage |
| Seasonal coverage | Images tagged for current season | Count of `seasonal_relevance` matches |

### Image Performance

| Metric | Baseline | How Measured |
|--------|----------|-------------|
| Image CTR by content category | TBD after 3 months | Average CTR per `content_category` |
| Flagging rate by category | TBD after 3 months | % of images flagged per category |
| Composition vs. CTR correlation | TBD after 6 months | Whether balanced compositions outperform |

---

## Potential Issues

### Technical

| Issue | Severity | Mitigation |
|-------|----------|------------|
| **Google Ads image URLs expire** | High | Download during bootstrap immediately; don't store URLs, store the actual images in S3 |
| **Claude Vision inconsistency** | Medium | Structured JSON prompt with explicit rules; log raw responses for audit; model version tracked in metadata |
| **Image hash collision after Google compression** | Low | If bootstrap images don't match originals, accept both as separate entries; dedupe by `asset_resource` not image hash |
| **Lambda timeout on large bootstrap** | Medium | Process images sequentially with progress tracking; retry from last successful image on timeout |
| **S3 costs** | Low | Image files are small (100KB-2MB each). At <100 images, storage cost is effectively zero |

### Data Quality

| Issue | Severity | Mitigation |
|-------|----------|------------|
| **AI miscategorizes an image** | Medium | Human can override `content_category` via manual update; composition analysis should still be directionally correct even with some miscategorization |
| **Performance attribution is campaign-level, not image-level** | High | This is a PMax limitation, not a system limitation. CTR per image is the best available signal but reflects headline pairing, audience, and placement â€” not image quality alone. Document this caveat prominently in Slack outputs |
| **Low volume = unreliable per-category performance data** | High | Don't derive dynamic profiles until minimum volume thresholds met (suggest: 1000+ impressions per category per campaign). Until then, use static profiles |

### Operational

| Issue | Severity | Mitigation |
|-------|----------|------------|
| **Operator ignores gap analysis recommendations** | Medium | Surface gaps in weekly Slack report, not just on-demand. Make it hard to miss |
| **Images added to Google Ads outside this system** | Medium | Weekly review detects unmapped `asset_resource` values and flags them: "2 images in Core Brand not in registry. Run bootstrap to sync." |
| **Image removed from Google Ads but not from registry** | Low | Weekly review sets `date_unlinked` on mapping entries for assets no longer returned by API |

---

## Future Improvements

### Phase 3: Dynamic Profiles

Once sufficient performance data exists (3+ months, 1000+ impressions per category):
- Calculate average CTR per `content_category` per campaign
- Weight profile targets toward higher-performing categories
- Alert when learned optimal mix diverges significantly from static profile
- Require human approval before profile changes take effect

### Phase 3: Automated Crop Generation

- When a slot needs filling and no native-ratio images exist, auto-generate crops from `crop_viable` images
- Use Claude Vision to validate the crop maintains composition quality
- Present crops for human approval before upload

### Phase 3: Selection Engine

When an image is flagged:
1. Query registry for available images matching the needed `field_type`
2. Rank by: content category gap impact, historical CTR in similar slots, seasonal relevance, diversity contribution
3. Present top 3 candidates in Slack with reasoning
4. Operator approves; system could eventually upload via Google Ads API

### Phase 4: Cross-Campaign Learning

- Track which `content_category` + `scene_type` + `product_frame_ratio` combinations correlate with high CTR
- Build a scoring model: "images with these attributes tend to perform well in prospecting campaigns"
- Apply scoring to new uploads: "This image scores 8/10 for Core Brand based on historical patterns"

### Phase 4: Competitive/Trend Analysis

- Periodic analysis of competitor PMax image strategies (via auction insights + manual review)
- Seasonal trend detection: "product_in_use images see +40% CTR in peak season"
- Inform profile shifts ahead of seasonal transitions

### Phase 4: Slack Workflow for Image Upload

- Operator drops an image into Slack DM
- Bot analyzes it, shows metadata, suggests which campaigns/slots it fits
- Operator confirms â†’ system uploads to S3, registers, and optionally pushes to Google Ads
- Eliminates the need to interact with S3 or Lambda directly

---

## Implementation Order

1. **Infrastructure:** S3 bucket + DynamoDB table + IAM permissions (Terraform)
2. **Image Manager module:** `src/image_manager.py` â€” S3 ops, Claude Vision analysis, registry CRUD
3. **Bootstrap:** Pull existing images from Google Ads, analyze, register
4. **Campaign profiles:** Add `image_profile` to settings, implement gap analysis
5. **image_ops Lambda:** Wire up bootstrap, upload, and gap analysis actions
6. **Weekly review integration:** Performance writeback + enriched flagging in Slack
7. **Testing:** Unit tests for gap analysis, integration test for bootstrap flow
